#!/usr/bin/python# -*- coding: utf-8 -*-# serial port for security panel unit by YuriyRimport serial, threading, time, sys, osimport Queueimport loggingSEPARATOR = "\\"if (os.name == "posix"):    SEPARATOR = "/"CurrDir = '\\'.join(sys.argv[0].split('\\')[:-1])#print 'CurrDir: "%s"' % CurrDirLOG_FILENAME = CurrDir+'\LogPG.txt'logging.basicConfig(level=logging.DEBUG,#logging.basicConfig(level=logging.INFO,                    format='%(asctime)s %(levelname)s %(message)s',                    filename=LOG_FILENAME                    #,filemode='w'                   )#logging.debug('This is a debug message')#logging.info('This is an info message')#logging.warning('This is a warning message')#logging.error('This is an error message')#logging.critical('This is a critical error message')def hexdump(str):    return ' '.join(["%02X" % ord(i) for i in str ])def hexdump2(str):    return ','.join(["0x%02X" % ord(i) for i in str ])def str_len_plus_str ( str ):    return chr( len(str) ) + strdef crc16(data):    crc = 0    for p in data:        crc += ord(p)    return chr(crc & 0x00ff)+chr((crc & 0xff00)>>8)def make_packet(proto, cmd, data):    p = chr(proto & 0xff)+chr(cmd & 0xff)+'\x00\x00' + str_len_plus_str(data)    crc = crc16(p)    return '\x0D' + p + crc + '\x0A'def make_host_packet(cmd,data):    data = chr(cmd) + data    l = 2 + len(data)    data = chr(l) + data    data = data + crc16(data)[0]+'\x0A'    return datadef generateSeq():    try:        f = open(CurrDir+"\seq","r")        seq = int(f.readline())        f.close()    except:        seq = 0    f = open(CurrDir+"\seq","w")    new_seq = seq+1    if new_seq == 256: new_seq = 1    f.write("%d" % new_seq)    f.close()    return seqdef generateSeq1():    try:        f = open(CurrDir+"\seq1","r")        seq = int(f.readline())        f.close()    except:        seq = 0    f = open(CurrDir+"\seq1","w")    new_seq = seq+1    if new_seq == 8: new_seq = 0    f.write("%d" % new_seq)    f.close()    return seqdef dev_serial(id):    #if not id>>13==0: print "Improper device id"    id_s=''    for i in range(4):        c = 0xff & id        id = id>>8        id_s = id_s + chr(c)    return id_sdef device_cmd( serial, short_id, mcode, mdata_type, mdata_value ):    # prepare device protocol    seq = generateSeq()    SerNum = dev_serial(int(serial))[:3]    mdata = chr(mcode) + str_len_plus_str( chr(mdata_type) + str_len_plus_str(mdata_value) )    device_packet = '\xE4\x00' + chr(seq) + SerNum + mdata    # prepare host protocol    #final_hop_info = '\x00\x4A\xED\x04\x88\x23\xF9\x10\x00\x00\x00' # real sniffer data    final_hop_info = '\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00' # D3: bit 7: 'Sync Flag'    relaying_repeater_ID = 0    repeater_hop_info = '\x00'*11    #host_protocol_message = make_host_packet( 0x30, chr(short_id)+'\x01\xF8'    #    +final_hop_info+chr(relaying_repeater_ID)+repeater_hop_info+str_len_plus_str(device_packet) )    host_protocol_message = make_host_packet( 0x30, chr(short_id)+chr(generateSeq1())+'\xF8'        +final_hop_info+chr(relaying_repeater_ID)+repeater_hop_info+str_len_plus_str(device_packet) )    return host_protocol_messagedef GetVoiceName(VoiceNumDec):    import csv    fiVoice = open("Modules"+SEPARATOR+"PowerMaster"+SEPARATOR+"VoiceTable.csv", "r")    rdrVoice = csv.DictReader(fiVoice,fieldnames=['VOICE_NAME', 'IN_USE', 'DecIdx'])    Cnt = 0    for recVoice in rdrVoice:        try:            if recVoice['VOICE_NAME'] != 'VOICE_NAME' and int(recVoice['IN_USE']) == 1:                #print '{0} - {1}'.format( '%03i'%Cnt, recVoice['VOICE_NAME'] )                if Cnt == VoiceNumDec: return recVoice['VOICE_NAME']                Cnt = Cnt + 1        except:            pass    return -1class packet:    def __init__(self, CmdNum):        self.CmdNum = CmdNum        self.data = ''        class COM_thr(threading.Thread):    def __init__(self):        threading.Thread.__init__(self)        #self.Cmd = packet( -1 )        self.ser = None        self.PortType = None        self.ev = {}        # create stop event        self.stop_event = threading.Event()        # create queue        self.queue = Queue.Queue()    def open_serial_port(self, PortNum, PortSpeed, PortType = 'PortAuto'):        self.PortType = PortType        self.ser = serial.Serial( PortNum, PortSpeed, timeout=0.1 )        self.start()    def close_serial_port(self):        self.ser.close()        self.ser = None    def send_host_cmd(self, pkt, f2_code = 9):        self.ser.read(self.ser.inWaiting())        #print 'packet (send_host_cmd): {0}'.format( hexdump(pkt) )        packet_f2 = make_packet( 0xF2, f2_code, pkt )        StrLog = '(send_host_cmd): {0}'.format( hexdump(packet_f2) )        print StrLog        logging.debug( StrLog )        self.ser.write(packet_f2)    def send_key(self, key):        keys = {'0':0,'1':1,'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9,'away':10,'home':11,'off':12,'*':13,'#':14,'back':15,'ok':16,'panic':17,'next':18,'record off':19,'fire':20,'emergency':21}        data = make_packet(0xF2,1,chr(keys[key]))        self.ser.write(data)    def SystemArm( self, arm_mode = 'away', code = '1111', PartNum = 0, ForPartLCD = '', IsQuickArm = 0 ):        ''' PartNum = 0 - all partition '''        if (arm_mode != 'away') and (arm_mode != 'home'):            print 'wrong arm_mode'            return 0                CmdLCD = packet(1)        ResSelPart = False        ResPart1 = False        ResLCD_SP_1 = False        if (PartNum > 0): # checking 3 LCD            CmdLCD.LCD = "SELECT PARTITION"            self.wait(CmdLCD, 'Start')            self.send_key('#')            ResSelPart = self.wait(CmdLCD, 'Check', 0.9)            time.sleep(0.150)            CmdLCD.LCD = "Partition 1"            self.wait(CmdLCD, 'Start')            self.send_key( str(PartNum) )            ResPart1 = self.wait(CmdLCD, 'Check', 0.9)            CmdLCD.LCD = "P1   RDY"            self.wait(CmdLCD, 'Start')            ResLCD_SP_1 = self.wait(CmdLCD, 'Check', 1.3)            time.sleep(0.150)        CmdLCD.LCD = "ENTER CODE:"        self.wait(CmdLCD, 'Start')        self.send_key(arm_mode)        ResLCD1 = self.wait(CmdLCD, 'Check', 1)        #CmdLCD.LCD = " P2"        # "ARMING  AWAY", "ARMING  HOME", "P1 ARM AWAY"        CmdLCD.LCD = "P1 ARM HOME"        if (arm_mode == 'away'): CmdLCD.LCD = "P1 ARM AWAY"        #CmdLCD.LCD = "ENTER CODE: ***"        self.wait(CmdLCD, 'Start')        Cnt = 0        for ch in code:            Cnt = Cnt + 1            # Without finding "ENTER CODE:":            print Cnt            if (arm_mode == 'away'):                ##time.sleep(0.100) # problem 1 - 100x4 key                time.sleep(0.150) # C16.001 problem 0 - 6x2000(x4 key), K13.024 (fail 0 from 1x1312(x4 key))                ##time.sleep(0.200) # I13.024 problem 0 - 2x2000(x4 key)            else:                #time.sleep(0.100) # home: problem 2 - 200x4 key                #time.sleep(0.120) # home: K13.027 problem 8 - 4000(x4 key)                time.sleep(0.150) #             self.send_key(ch)        if arm_mode == 'away': time.sleep(0.100)        ResLCD2 = self.wait(CmdLCD, 'Check', 1)        #ResLCD2 = True        #if (ResLCD1 == False) or (ResLCD2 == False):        Res = ResSelPart and ResPart1 and ResLCD_SP_1 and ResLCD1 and ResLCD2        print 'AWAY End'        return Res            def away(self, code):        #Res = True        CmdLCD = packet(1)                CmdLCD.LCD = "ENTER CODE:"        self.wait(CmdLCD, 'Start')        self.send_key('away')        ResLCD1 = self.wait(CmdLCD, 'Check', 1)                CmdLCD.LCD = " P2"        self.wait(CmdLCD, 'Start')        for c in code:            # Without finding "ENTER CODE:":            ##time.sleep(0.100) # problem 1 - 100x4 key            time.sleep(0.150) # C16.001 problem 0 - 6x2000(x4 key), K13.024 (fail 0 from 1x1312(x4 key))            ##time.sleep(0.200) # I13.024 problem 0 - 2x2000(x4 key)            self.send_key(c)        time.sleep(0.100)        ResLCD2 = self.wait(CmdLCD, 'Check', 1)                #if (ResLCD1 == False) or (ResLCD2 == False):        Res = ResLCD1 and ResLCD2        print 'AWAY End'        return Res    def home(self, code):        self.send_key('home')        for c in code:            self.send_key(c)        print 'HOME'        return True            def disarm(self, code):        self.send_key('off')        #time.sleep(0.5)        for c in code:            #time.sleep(0.12) # enough?            time.sleep(0.30) # enough?            self.send_key(c)        time.sleep(0.100)        print 'DISARM End'        return True    def run(self):        pid = os.getpid()        sys.stdout.write( 'run thread (process ID = {0})\n'.format(pid) )        sys.stdout.flush()        if self.PortType == 'PortAuto': self.ThreadPortAuto()        else: self.ThreadPortRF()        sys.stdout.write( 'thread stopped\n' )        sys.stdout.flush()        def ThreadPortAuto(self):        IsStartPack = 0        ProtocolNumHex = hex(0x00)        PackCharNum = 0        PckDataLen = 0        PktStrHex = ''        BufPckDec = []        CmdNum = 0        CmdNumHex = 0x00        # LCD packet        buffer_LCD = ''        t1 = time.time()                #while True:        while not self.stop_event.is_set():            #result = select.select([self.sock],[],[]) # Only Linux?            data_size = self.ser.inWaiting()            if data_size == 0:                #sys.stdout.write( '(data_size == 0)\n' )                #time.sleep(0.19)                time.sleep(0.09)                continue            new_data = self.ser.read(1)            PackCharNum = PackCharNum + 1            BufPckDec.append( ord(new_data) )                        if PackCharNum > 1: PktStrHex = PktStrHex + ' '            PktStrHex = PktStrHex + '%02X' % ord(new_data)            #print '{0}'.format( PktStrHex )                        #if hex(ord(new_data)) == '0xd': # begin packet            if hex(ord(new_data)) == hex(0x0D): # begin packet                IsStartPack = 1                #PktStrHex = '{0}(d)'.format( PktStrHex )                        fnd = PktStrHex.find('0D A5')            if (IsStartPack == 1) and (fnd > (-1)): # '0x0D 0xA5'                PktStrHex = PktStrHex + '(?)'                        fnd = PktStrHex.find('0D F2')            if (IsStartPack == 1) and (fnd > (-1)): # '0x0D 0xF2'                if fnd > 0:                    print 'TRASH FOUND??: {0}'#.format( hexdump(pack[:fnd]) )                    #pack = pack[fnd:] # cut buffer                else:                    ProtocolNumHex = hex(BufPckDec[PackCharNum-1])                    #PktStrHex = '{0}({1})'.format( PktStrHex, hex(BufPckDec[PackCharNum-1]) )                IsStartPack = 0            if (ProtocolNumHex == hex(0xF2)) and (PackCharNum == 3): # CmdNum                CmdNum = BufPckDec[PackCharNum-1]                CmdNumHex = hex(BufPckDec[PackCharNum-1])                if   (CmdNumHex == hex(0x01)): # LCD                    PktStrHex = PktStrHex + '[LCD]'                elif (CmdNumHex == hex(0x02)): # Voice                    PktStrHex = PktStrHex + '[Vce]'                elif (CmdNumHex == hex(0x03)): # Buzzer                    PktStrHex = PktStrHex + '[Bzr]'                elif (CmdNumHex == hex(0x04)): # Led                    PktStrHex = PktStrHex + '[Led]'                elif (CmdNumHex == hex(0x06)): # packet with panel event                    PktStrHex = PktStrHex + '[PEv]'                elif (CmdNumHex == hex(0x0B)): # Device associated (for confirm enrollment)                    PktStrHex = PktStrHex + '[Enr]'                #sys.stdout.write( '({0}:{1})'.format( CmdNum, CmdNumHex ) )            if (ProtocolNumHex == hex(0xF2)) and (PackCharNum == 6): # PckDataLen                PckDataLen = ord(new_data)                PktStrHex = PktStrHex + '{0}'.format( '(%02d)' % PckDataLen )                continue            if (ProtocolNumHex == hex(0xF2)) and (PackCharNum > (6)) and (PackCharNum <= (6+PckDataLen)): # data in packet                if (CmdNumHex == hex(0x01)): # LCD                    buffer_LCD = buffer_LCD + new_data                    if (PackCharNum == (6+PckDataLen)): # finished read LCD                        self.queue.put('"' + buffer_LCD + '"\n')                        #sys.stdout.write( ' "' + buffer_LCD + '"' )                        PktStrHex = PktStrHex + ' "%s"' % buffer_LCD                elif (CmdNumHex == hex(0x02)): # Voice                    PktStrHex = PktStrHex + '[{0}]'.format( GetVoiceName(ord(new_data)) )                continue            if (hex(ord(new_data)) == '0xa') and not ((PackCharNum > (6)) and (PackCharNum <= (6+PckDataLen))): # symbol end packet and not in data                #if (CmdNumHex == hex(0x01)): # LCD                t2 = time.time()                logging.debug( '{0} (+{1}) {2}'.format( time.strftime("%M:%S", time.localtime()), '%.2f'%(t2-t1), PktStrHex ) )                sys.stdout.write( '{0} (+{1}) {2}'.format( time.strftime("%M:%S", time.localtime()), '%.2f'%(t2-t1), PktStrHex ) )                t1 = time.time()                if (CmdNum in self.ev):                    if (CmdNumHex == hex(0x01)): # LCD                        #sys.stdout.write( ' (1) "{0}" "{1}"'.format( self.LCD, buffer_LCD ) )                        if (self.LCD in buffer_LCD) or (self.LCD == ''):                            self.ev[CmdNum].set()                            #sys.stdout.write( '\n(LCD "{0}" found)'.format( self.LCD ) )                    elif (CmdNumHex == hex(0x02)): # Voice                        pass                    elif (CmdNumHex == hex(0x03)): # Buzzer                        if self.BzrNum == BufPckDec[6+1-1]:                            sys.stdout.write( ' (Bzr "{0}" found)'.format( self.BzrNum ) )                            self.ev[CmdNum].set()                    elif (CmdNumHex == hex(0x06)): # Panel event                        if (self.EvNum == BufPckDec[7+1-1]) and (self.SourceNum == BufPckDec[6+1-1]):                            sys.stdout.write( ' (EvNum "{0}" found. SourceNum "{1}")'.format( self.EvNum, self.SourceNum ) )                            self.ev[CmdNum].set()                    elif (CmdNumHex == hex(0x0B)): # for enroll                        self.ShortID = BufPckDec[12]                        self.DevTypeNum = BufPckDec[13]                        self.DevNum = BufPckDec[14]                        sys.stdout.write( ' (Cmd 0x0B found. ShortID: {0}, DevTypeNum: {1}, DevNum: {2})'.format( self.ShortID, self.DevTypeNum, self.DevNum ) )                        self.ev[CmdNum].set()                    else:                        self.ev[CmdNum].set()                        sys.stdout.write( ' (other cmd found)' )                        #sys.stdout.flush()                ProtocolNumHex = hex(0x00)                PackCharNum = 0                PckDataLen = 0                PktStrHex = ''                buffer_LCD = ''                del BufPckDec[:]                CmdNum = 0                CmdNumHex = 0x00                sys.stdout.write( '\n' )            #else:            #    if PackCharNum >= 3: sys.stdout.write( ' ' )            sys.stdout.flush()    def ThreadPortRF(self):        IsStartPack = 0        ProtocolNumHex = hex(0x00)        PackCharNum = 0        PckDataLen = 0        PktStrHex = ''        BufPckDec = []        CmdNum = 0        CmdNumHex = 0x00        # LCD packet        buffer_LCD = ''        t1 = time.time()                #while True:        while not self.stop_event.is_set():            #result = select.select([self.sock],[],[]) # Only Linux?            data_size = self.ser.inWaiting()            if data_size == 0:                #sys.stdout.write( '(data_size == 0)\n' )                #time.sleep(0.19)                time.sleep(0.09)                continue            new_data = self.ser.read(1)            PackCharNum = PackCharNum + 1            BufPckDec.append( ord(new_data) )            PktStrHex = PktStrHex + '%02X' % ord(new_data)            if PackCharNum >= 1: PktStrHex = PktStrHex + ' '            sys.stdout.write( '{0}'.format( '%02X' % ord(new_data) ) )            if PackCharNum >= 1: sys.stdout.write( ' ' )            sys.stdout.flush()            if PackCharNum == 1:                sys.stdout.write( '[B={0}]'.format( ord(new_data) ) )                sys.stdout.write( ' ' )                sys.stdout.flush()            if (PackCharNum > 1) and (PackCharNum < BufPckDec[0]): # PckDataLen                continue            if ((PackCharNum+1) == BufPckDec[0]) and (hex(ord(new_data)) != hex(0x0A)): # Error End packet                sys.stdout.write( '[Error End packet] ' )                sys.stdout.flush()            if (hex(ord(new_data)) == hex(0x0A)):                #sys.stdout.write( '{0}'.format( PktStrHex ) )                sys.stdout.write( '\n' )                sys.stdout.flush()                PackCharNum = 0                PktStrHex = ''                del BufPckDec[:]                def wait(self, Cmd, AsyncMode = '', Timeout = 10):        Res = False        LogStr = ''        if   Cmd.CmdNum == 1: self.LCD = Cmd.LCD        elif Cmd.CmdNum == 2: pass # Voice        elif Cmd.CmdNum == 3: self.BzrNum = Cmd.BzrNum        elif Cmd.CmdNum == 6: # Event            self.EvNum  = Cmd.EvNum            self.SourceNum  = Cmd.SourceNum        elif Cmd.CmdNum == 11: # for enroll            self.ShortID  = -1            self.DevTypeNum = -1            self.DevNum = -1        else:            logging.debug( '(wait) unknown command' )            sys.stdout.write( '(wait) unknown command\n' )            sys.stdout.flush()                if AsyncMode == 'Start':            self.ev[Cmd.CmdNum] = threading.Event()            self.ev[Cmd.CmdNum].clear()            Res = True                    if AsyncMode == 'Check':            self.ev[Cmd.CmdNum].wait(Timeout)            if self.ev[Cmd.CmdNum].is_set():                #print "cmd {0} found".format( Cmd.CmdNum )                Res = True                if   Cmd.CmdNum == 1:   pass                elif Cmd.CmdNum == 11:                    Cmd.ShortID = self.ShortID                    Cmd.DevTypeNum = self.DevTypeNum                    Cmd.DevNum = self.DevNum            else:                if   Cmd.CmdNum == 1:  LogStr = 'cmd {0} don`t found. Name: "{1}"'.format( Cmd.CmdNum, Cmd.LCD )                #elif Cmd.CmdNum == 2:  LogStr = 'cmd {0} don`t found. Voice: "{1}"'.format( Cmd.CmdNum, Cmd.LCD )                elif Cmd.CmdNum == 3:  LogStr = 'cmd {0} don`t found. Bzr: "{1}"'.format( Cmd.CmdNum, Cmd.BzrNum )                elif Cmd.CmdNum == 6:  LogStr = 'cmd {0} don`t found. EvNum: "{1}"'.format( Cmd.CmdNum, Cmd.EvNum )                elif Cmd.CmdNum == 11:                    LogStr = 'cmd {0} don`t found. CmdNum: "{1}"'.format( Cmd.CmdNum, Cmd.CmdNum ) # for enroll                logging.debug( '{0}'.format( LogStr ) )                sys.stdout.write( '{0}\n'.format( LogStr ) )                sys.stdout.flush()            del self.ev[Cmd.CmdNum]        return Resif __name__ == "__main__":    pass